# 시계맞추기 ClockSync
## 문제 설명
4 x 4 격자에 시계가 있는데 이 시계들은 각자 3, 6, 9, 12시를 가리키고 있다. 주어진 스위치는 10개가 있는데 각 스위치 별로 3 ~ 5개의 시계와 연결되어있다. \
스위치를 누르면 연결된 시계가 앞으로 3시간 움직인다. 모든 시계를 12시로 맞추기 위한 최소 스위치 누름 수는 몇번인가?

```
# 스위치에 연결된 시계들
0 - 0,1,2
1 - 3,7,9,11
2 - 4,10,14,15
3 - 0,4,5,6,7
4 - 6,7,8,10,12
5 - 0,2,14,15
6 - 3,14,15
7 - 4,5,7,14,15
8 - 1,2,3,4,5
9 - 3,4,5,9,13
```

## 자료구조, 함수 상상
- 스위치는 2차원 배열로 표기할 수 있어보임.
- 시계는 1차원 배열로 value 는 0, 1, 2, 3 만 지니도록 구현.
- 스위치를 누르는 push 함수 인자 - switchNum

## 풀이 전략
스위치를 누르는 순서는 중요하지 않으므로 중복을 제거하기 위해 낮은 번호부터 누른다. \
각 스위치는 4가지 선택이 가능하므로 도출될 수 있는 모든 경우의 수는 4의 10승으로 충분히 완전 탐색도 가능함. \
일단 완전탐색을 짜보도록 하자.

## 비교
풀이 전략, 접근방식을 맞췄고 문제를 풀 수 있었다. 다만 아직 재귀함수의 사용이 대단히 익숙해 졌다고는 할 수 없다. \
답안과 비교해 봤을 때 디테일 부분에서 차이가 있다.

```java
static int total = Integer.MAX_VALUE; // 답안을 기억하기 위한 전역변수
public boolean count(int[] clocks, int num, int numSwitchPushedFromPrevSteps); // 재귀함수

// vs

int solve(int[] clocks, int swtch);
```

누가 보아도 아래방식이 간단하다는 것을 알 수 있다. 나는 불필요한 인수와 전역변수를 두었고 답안은 이를 함수의 리턴으로 해결했다 \
정답을 만들 때 정답의 형태에 따라 인수를 넘기는 방식을 채택할 것인지, 리턴으로 합칠 것인지 잘 생각해 봐야겠다.